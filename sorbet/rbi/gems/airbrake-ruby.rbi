# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/airbrake-ruby/all/airbrake-ruby.rbi
#
# airbrake-ruby-4.8.0
module Airbrake
  def self.add_filter(filter = nil, &block); end
  def self.add_performance_filter(filter = nil, &block); end
  def self.build_notice(exception, params = nil); end
  def self.close; end
  def self.configure; end
  def self.configured?; end
  def self.delete_filter(filter_class); end
  def self.delete_performance_filter(filter_class); end
  def self.deploy_notifier; end
  def self.deploy_notifier=(arg0); end
  def self.merge_context(context); end
  def self.notice_notifier; end
  def self.notice_notifier=(arg0); end
  def self.notify(exception, params = nil, &block); end
  def self.notify_deploy(deploy_info); end
  def self.notify_performance_breakdown(breakdown_info, stash = nil); end
  def self.notify_query(query_info, stash = nil); end
  def self.notify_request(request_info, stash = nil); end
  def self.notify_sync(exception, params = nil, &block); end
  def self.performance_notifier; end
  def self.performance_notifier=(arg0); end
  def self.process_config_options(config); end
  def self.reset; end
end
module Airbrake::Loggable
  def logger; end
  def self.instance; end
  def self.instance=(arg0); end
end
module Airbrake::Stashable
  def stash; end
end
class Airbrake::Config
  def app_version; end
  def app_version=(arg0); end
  def blacklist_keys; end
  def blacklist_keys=(arg0); end
  def check_configuration; end
  def check_notify_ability; end
  def check_performance_options(resource); end
  def code_hunks; end
  def code_hunks=(arg0); end
  def endpoint; end
  def environment; end
  def environment=(arg0); end
  def host; end
  def host=(arg0); end
  def ignore_environments; end
  def ignore_environments=(arg0); end
  def ignored_environment?; end
  def initialize(user_config = nil); end
  def logger; end
  def logger=(logger); end
  def merge(config_hash); end
  def performance_stats; end
  def performance_stats=(arg0); end
  def performance_stats_flush_period; end
  def performance_stats_flush_period=(arg0); end
  def project_id; end
  def project_id=(arg0); end
  def project_key; end
  def project_key=(arg0); end
  def proxy; end
  def proxy=(arg0); end
  def query_stats; end
  def query_stats=(arg0); end
  def queue_size; end
  def queue_size=(arg0); end
  def root_directory; end
  def root_directory=(arg0); end
  def self.instance; end
  def self.instance=(arg0); end
  def set_option(option, value); end
  def timeout; end
  def timeout=(arg0); end
  def valid?; end
  def validate; end
  def versions; end
  def versions=(arg0); end
  def whitelist_keys; end
  def whitelist_keys=(arg0); end
  def workers; end
  def workers=(arg0); end
end
class Airbrake::Config::Validator
  def self.check_notify_ability(config); end
  def self.ignored_environment?(config); end
  def self.valid_environment?(config); end
  def self.valid_project_id?(config); end
  def self.valid_project_key?(config); end
  def self.validate(config); end
end
class Airbrake::Promise
  def initialize; end
  def reject(reason = nil); end
  def rejected?; end
  def rescue(&block); end
  def resolve(reason = nil); end
  def resolved?; end
  def then(&block); end
  def value; end
end
class Airbrake::ThreadPool
  def <<(message); end
  def backlog; end
  def close; end
  def closed?; end
  def has_workers?; end
  def initialize(worker_size:, queue_size:, block:); end
  def spawn_worker; end
  def spawn_workers; end
  def workers; end
  include Airbrake::Loggable
end
class Airbrake::SyncSender
  def build_https(uri); end
  def build_request(uri, data); end
  def build_request_body(req, data); end
  def initialize(method = nil); end
  def missing_body?(req, promise); end
  def proxy_params; end
  def rate_limited_ip?(promise); end
  def send(data, promise, endpoint = nil); end
  include Airbrake::Loggable
end
class Airbrake::AsyncSender
  def close; end
  def closed?; end
  def has_workers?; end
  def initialize(method = nil); end
  def send(notice, promise, endpoint = nil); end
  def thread_pool; end
  def will_not_deliver(notice, promise); end
  include Airbrake::Loggable
end
module Airbrake::Response
  def self.parse(response); end
  def self.rate_limit_reset(response); end
  def self.truncated_body(body); end
end
class Airbrake::NestedException
  def as_json; end
  def initialize(exception); end
  def unwind_exceptions; end
end
module Airbrake::Ignorable
  def ignore!; end
  def ignored; end
  def ignored=(arg0); end
  def ignored?; end
  def raise_if_ignored; end
end
module Airbrake::Inspectable
  def inspect; end
  def pretty_print(q); end
end
class Airbrake::Notice
  def [](key); end
  def []=(key, value); end
  def context; end
  def initialize(exception, params = nil); end
  def to_json; end
  def truncate; end
  include Airbrake::Ignorable
  include Airbrake::Loggable
  include Airbrake::Stashable
end
module Airbrake::Backtrace
  def self.best_regexp_for(exception); end
  def self.execjs_exception?(exception); end
  def self.frame_in_root?(frame, root_directory); end
  def self.java_exception?(exception); end
  def self.match_frame(regexp, stackframe); end
  def self.oci_exception?(exception); end
  def self.parse(exception); end
  def self.parse_backtrace(exception); end
  def self.populate_code(frame); end
  def self.stack_frame(regexp, stackframe); end
end
module Airbrake::Backtrace::Patterns
end
class Airbrake::Truncator
  def initialize(max_size); end
  def reduce_max_size; end
  def replace_invalid_characters(str); end
  def stringify_object(object); end
  def truncate(object, seen = nil); end
  def truncate_array(array, seen); end
  def truncate_hash(hash, seen); end
  def truncate_object(object, seen); end
  def truncate_set(set, seen); end
  def truncate_string(str); end
end
module Airbrake::Filters
end
module Airbrake::Filters::KeysFilter
  def call(notice); end
  def eval_proc_patterns!; end
  def filter_context_key(notice, key); end
  def filter_hash(hash); end
  def filter_url(notice); end
  def filter_url_params(url); end
  def initialize(patterns); end
  def should_filter?(_key); end
  def validate_patterns; end
  def weight; end
  include Airbrake::Loggable
end
class Airbrake::Filters::KeysWhitelist
  def initialize(*arg0); end
  def should_filter?(key); end
  include Airbrake::Filters::KeysFilter
end
class Airbrake::Filters::KeysBlacklist
  def initialize(*arg0); end
  def should_filter?(key); end
  include Airbrake::Filters::KeysFilter
end
class Airbrake::Filters::GemRootFilter
  def call(notice); end
  def initialize; end
  def weight; end
end
class Airbrake::Filters::SystemExitFilter
  def call(notice); end
  def initialize; end
  def weight; end
end
class Airbrake::Filters::RootDirectoryFilter
  def call(notice); end
  def initialize(root_directory); end
  def weight; end
end
class Airbrake::Filters::ThreadFilter
  def add_thread_info(th, thread_info); end
  def call(notice); end
  def fiber_variables(th); end
  def initialize; end
  def sanitize_value(value); end
  def thread_variables(th); end
  def weight; end
end
class Airbrake::Filters::ContextFilter
  def call(notice); end
  def initialize(context); end
  def weight; end
end
class Airbrake::Filters::ExceptionAttributesFilter
  def call(notice); end
  def initialize; end
  include Airbrake::Loggable
end
class Airbrake::Filters::DependencyFilter
  def call(notice); end
  def git_version(spec); end
  def initialize; end
end
class Airbrake::Filters::GitRevisionFilter
  def call(notice); end
  def find_from_packed_refs(head); end
  def find_revision; end
  def initialize(root_directory); end
  def weight; end
end
class Airbrake::Filters::GitRepositoryFilter
  def attach_repository(notice); end
  def call(notice); end
  def detect_git_version; end
  def initialize(root_directory); end
  def weight; end
  def which(cmd); end
end
class Airbrake::Filters::GitLastCheckoutFilter
  def call(notice); end
  def checkout_line?(line); end
  def initialize(root_directory); end
  def last_checkout; end
  def last_checkout_line; end
  def timestamp(utime); end
  def weight; end
  include Airbrake::Loggable
end
class Airbrake::Filters::SqlFilter
  def call(resource); end
  def initialize(dialect); end
end
class Airbrake::FilterChain
  def add_filter(filter); end
  def delete_filter(filter_class); end
  def initialize; end
  def inspect; end
  def pretty_print(q); end
  def refine(notice); end
end
class Airbrake::CodeHunk
  def get(file, line); end
  def get_from_cache(file); end
  def get_lines(file, start_line, end_line); end
  include Airbrake::Loggable
end
module Airbrake::FileCache
  def self.[](key); end
  def self.[]=(key, value); end
  def self.data; end
  def self.empty?; end
  def self.reset; end
end
module Airbrake::HashKeyable
  def eql?(other); end
  def hash; end
end
class Airbrake::PerformanceNotifier
  def add_filter(filter = nil, &block); end
  def close; end
  def delete_filter(filter_class); end
  def initialize; end
  def notify(resource); end
  def schedule_flush; end
  def send(payload, promise); end
  def serialize_resources(resources); end
  def spawn_timer; end
  def update_payload(resource); end
  def with_grouped_payload(raw_payload); end
  include Airbrake::Inspectable
  include Airbrake::Loggable
end
class Airbrake::NoticeNotifier
  def add_filter(filter = nil, &block); end
  def build_notice(exception, params = nil); end
  def clean_backtrace; end
  def close; end
  def configured?; end
  def convert_to_exception(ex); end
  def default_sender; end
  def delete_filter(filter_class); end
  def initialize; end
  def merge_context(context); end
  def notify(exception, params = nil, &block); end
  def notify_sync(exception, params = nil, &block); end
  def send_notice(exception, params, sender); end
  include Airbrake::Inspectable
  include Airbrake::Loggable
end
class Airbrake::DeployNotifier
  def initialize; end
  def notify(deploy_info); end
  include Airbrake::Inspectable
end
class Airbrake::Stat < Struct
  def count; end
  def count=(_); end
  def increment(start_time, end_time = nil); end
  def increment_ms(ms); end
  def initialize(count: nil, sum: nil, sumsq: nil, tdigest: nil); end
  def inspect; end
  def pretty_print; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sum; end
  def sum=(_); end
  def sumsq; end
  def sumsq=(_); end
  def tdigest; end
  def tdigest=(_); end
  def to_h; end
end
module Airbrake::TimeTruncate
  def self.utc_truncate_minutes(time); end
end
class Airbrake::TDigest
  def +(other); end
  def _add_weight(nearest, x, n); end
  def _cumulate(exact = nil, force = nil); end
  def _digest(x, n); end
  def _new_centroid(x, n, cumn); end
  def as_bytes; end
  def as_json(_ = nil); end
  def as_small_bytes; end
  def bound_mean(x); end
  def bound_mean_cumn(cumn); end
  def centroids; end
  def centroids=(arg0); end
  def compress!; end
  def compression; end
  def find_nearest(x); end
  def initialize(delta = nil, k = nil, cx = nil); end
  def merge!(other); end
  def p_rank(x); end
  def percentile(p); end
  def push(x, n = nil); end
  def push_centroid(c); end
  def reset!; end
  def self.from_bytes(bytes); end
  def self.from_json(array); end
  def size; end
  def to_a; end
end
class Airbrake::TDigest::Centroid
  def as_json(_ = nil); end
  def cumn; end
  def cumn=(arg0); end
  def initialize(mean, n, cumn, mean_cumn = nil); end
  def mean; end
  def mean=(arg0); end
  def mean_cumn; end
  def mean_cumn=(arg0); end
  def n; end
  def n=(arg0); end
end
class Airbrake::Query < Struct
  def cargo; end
  def destination; end
  def end_time; end
  def end_time=(_); end
  def file; end
  def file=(_); end
  def func; end
  def func=(_); end
  def groups; end
  def initialize(method:, route:, query:, start_time:, func: nil, file: nil, line: nil, end_time: nil); end
  def line; end
  def line=(_); end
  def method; end
  def method=(_); end
  def query; end
  def query=(_); end
  def route; end
  def route=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start_time; end
  def start_time=(_); end
  def to_h; end
  include Airbrake::HashKeyable
  include Airbrake::Ignorable
  include Airbrake::Stashable
end
class Airbrake::Request < Struct
  def cargo; end
  def destination; end
  def end_time; end
  def end_time=(_); end
  def groups; end
  def initialize(method:, route:, status_code:, start_time:, end_time: nil); end
  def method; end
  def method=(_); end
  def route; end
  def route=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start_time; end
  def start_time=(_); end
  def status_code; end
  def status_code=(_); end
  def to_h; end
  include Airbrake::HashKeyable
  include Airbrake::Ignorable
  include Airbrake::Stashable
end
class Airbrake::PerformanceBreakdown < Struct
  def cargo; end
  def destination; end
  def end_time; end
  def end_time=(_); end
  def groups; end
  def groups=(_); end
  def initialize(method:, route:, response_type:, groups:, start_time:, end_time: nil); end
  def method; end
  def method=(_); end
  def response_type; end
  def response_type=(_); end
  def route; end
  def route=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start_time; end
  def start_time=(_); end
  def to_h; end
  include Airbrake::HashKeyable
  include Airbrake::Ignorable
  include Airbrake::Stashable
end
class Airbrake::Benchmark
  def duration; end
  def initialize; end
  def self.measure; end
  def stop; end
end
module Airbrake::MonotonicTime
  def self.time_in_ms; end
  def self.time_in_nanoseconds; end
end
class Airbrake::TimedTrace
  def initialize; end
  def self.span(label, &block); end
  def span(label); end
  def spans; end
  def start_span(label); end
  def stop_span(label); end
end
class Airbrake::Error < StandardError
end
